<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Epicycles — Fourier Drawing Machine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Bebas+Neue&display=swap');

  :root {
    --bg: #07080c;
    --surface: #0d0f18;
    --panel: #10121c;
    --border: #1c1f30;
    --accent: #00e5ff;
    --accent2: #ff2d78;
    --accent3: #ffe566;
    --text: #c8d0e8;
    --muted: #444a66;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    flex-shrink: 0;
    gap: 12px;
    flex-wrap: wrap;
  }

  .logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.5rem;
    letter-spacing: 0.15em;
    color: var(--accent);
    text-shadow: 0 0 18px rgba(0,229,255,0.45);
    flex-shrink: 0;
  }
  .logo span { color: var(--accent2); }

  .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  .btn {
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    padding: 6px 13px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
    border-radius: 2px;
    white-space: nowrap;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,229,255,0.05); }
  .btn.active { border-color: var(--accent2); color: var(--accent2); background: rgba(255,45,120,0.08); }
  .btn.primary { border-color: var(--accent); color: var(--accent); background: rgba(0,229,255,0.07); }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 7px;
    font-size: 0.62rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--muted);
  }
  input[type=range] {
    -webkit-appearance: none;
    width: 80px; height: 2px;
    background: var(--border);
    outline: none; border-radius: 2px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 11px; height: 11px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 7px rgba(0,229,255,0.6);
  }
  .val-display { color: var(--accent); font-size: 0.72rem; min-width: 26px; text-align: right; }

  .main { display: flex; flex: 1; overflow: hidden; position: relative; }
  canvas { flex: 1; display: block; cursor: crosshair; }

  .sidebar {
    width: 190px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    padding: 14px;
    gap: 10px;
    flex-shrink: 0;
    overflow-y: auto;
  }

  .sidebar-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 0.15em;
    color: var(--muted);
    border-bottom: 1px solid var(--border);
    padding-bottom: 6px;
  }

  .shape-btn {
    font-family: 'Space Mono', monospace;
    font-size: 0.62rem;
    letter-spacing: 0.07em;
    text-transform: uppercase;
    padding: 7px 10px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
    text-align: left;
    border-radius: 2px;
    width: 100%;
  }
  .shape-btn:hover { border-color: var(--accent3); color: var(--accent3); background: rgba(255,229,102,0.05); }
  .shape-btn.active { border-color: var(--accent3); color: var(--accent3); }

  .toggle-label {
    font-size: 0.62rem; color: var(--muted); letter-spacing: 0.06em;
    cursor: pointer; display: flex; align-items: center; gap: 8px;
  }
  input[type=checkbox] { accent-color: var(--accent); }

  .status {
    margin-top: auto;
    font-size: 0.58rem;
    color: var(--muted);
    letter-spacing: 0.05em;
    line-height: 2;
  }
  .status .val { color: var(--text); }

  #hint {
    position: absolute;
    bottom: 18px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.6rem;
    color: var(--muted);
    letter-spacing: 0.08em;
    text-align: center;
    pointer-events: none;
    transition: opacity 0.4s;
    white-space: nowrap;
  }

  .num-input {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    width: 44px;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--accent);
    padding: 2px 5px;
    border-radius: 2px;
    text-align: center;
    outline: none;
    -moz-appearance: textfield;
  }
  .num-input::-webkit-inner-spin-button,
  .num-input::-webkit-outer-spin-button { -webkit-appearance: none; }
  .num-input:focus { border-color: var(--accent); }

  #modeTag {
    font-size: 0.6rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 4px 8px;
    border: 1px solid var(--border);
    border-radius: 2px;
    flex-shrink: 0;
  }
</style>
</head>
<body>

<header>
  <div class="logo">EPIC<span>YCLES</span></div>
  <div class="controls">
    <div class="slider-group">
      <span>Circles</span>
      <input type="range" id="numCircles" min="1" max="200" value="60">
      <input type="number" class="num-input" id="numCirclesInput" min="1" max="200" value="60">
    </div>
    <div class="slider-group">
      <span>Speed</span>
      <input type="range" id="speedSlider" min="2" max="20" value="4">
      <input type="number" class="num-input" id="speedInput" min="2" max="20" value="4">
    </div>
    <button class="btn" id="drawBtn">✏ Draw</button>
    <button class="btn primary" id="playBtn">▶ Play</button>
    <button class="btn" id="pauseBtn">⏸ Pause</button>
    <button class="btn" id="clearBtn">✕ Clear</button>
  </div>
  <div id="modeTag">PRESET</div>
</header>

<div class="main">
  <canvas id="canvas"></canvas>

  <div class="sidebar">
    <div class="sidebar-title">Presets</div>
    <button class="shape-btn" data-shape="heart">♥  Heart</button>
    <button class="shape-btn" data-shape="circle">◯  Circle</button>
    <button class="shape-btn" data-shape="star">★  Star</button>
    <button class="shape-btn" data-shape="lissajous">≋  Lissajous</button>
    <button class="shape-btn" data-shape="trefoil">✦  Trefoil</button>
    <button class="shape-btn" data-shape="butterfly">⌘  Butterfly</button>

    <div class="sidebar-title" style="margin-top:6px">Display</div>
    <label class="toggle-label"><input type="checkbox" id="showCircles" checked> Circles</label>
    <label class="toggle-label"><input type="checkbox" id="showArms" checked> Arms</label>
    <label class="toggle-label"><input type="checkbox" id="showTrace" checked> Trace</label>

    <div class="status">
      Circles: <span class="val" id="s-n">--</span><br>
      Points: <span class="val" id="s-pts">--</span><br>
      Phase: <span class="val" id="s-phase">--</span>
    </div>
  </div>

  <div id="hint">Pick a preset or click ✏ Draw to sketch your own shape</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = canvas.offsetWidth;
  H = canvas.height = canvas.offsetHeight;
}
window.addEventListener('resize', () => { resize(); if (fourier.length) restart(); });
resize();

// ── State ──────────────────────────────────────────────────────────────────────
let mode = 'idle';
let isMouseDown = false;
let sketchPoints = [];
let originalPts = [];   // centered input points for ghost drawing
let fourier = [];       // sorted DFT bins
let dftN = 0;           // number of input points used for DFT
let time = 0;           // sweeps 0 → dftN (one full cycle = dftN steps)
let tracePoints = [];    // live-accumulated trace, cleared each cycle
let animId = null;
let paused = false;
let numCircles = 60;
let animSpeed = 4;
let showCircles = true;
let showArms    = true;
let showTrace   = true;

// ── Controls ───────────────────────────────────────────────────────────────────
document.getElementById('numCircles').addEventListener('input', e => {
  numCircles = +e.target.value;
  if (fourier.length) restart();
});
document.getElementById('speedSlider').addEventListener('input', e => {
  animSpeed = +e.target.value;
  time = 0; tracePoints = [];
});
document.getElementById('showCircles').addEventListener('change', e => showCircles = e.target.checked);
document.getElementById('showArms').addEventListener('change',    e => showArms    = e.target.checked);
document.getElementById('showTrace').addEventListener('change',   e => showTrace   = e.target.checked);
document.getElementById('drawBtn').addEventListener('click', enterDrawMode);
document.getElementById('playBtn').addEventListener('click', () => {
  if (mode === 'drawing' && sketchPoints.length > 10) {
    beginPlay(resample(sketchPoints, 512));
  } else if (fourier.length) {
    restart();
  }
});
document.getElementById('clearBtn').addEventListener('click', fullReset);

// Number inputs stay in sync with sliders
document.getElementById('numCirclesInput').addEventListener('change', e => {
  const v = Math.min(200, Math.max(1, +e.target.value || 1));
  e.target.value = v;
  numCircles = v;
  document.getElementById('numCircles').value = v;
  if (fourier.length) restart();
});
document.getElementById('speedInput').addEventListener('change', e => {
  const v = Math.min(20, Math.max(2, +e.target.value || 2));
  e.target.value = v;
  animSpeed = v;
  time = 0; tracePoints = [];
  document.getElementById('speedSlider').value = v;
});

// Keep sliders synced to number inputs
document.getElementById('numCircles').addEventListener('input', e => {
  document.getElementById('numCirclesInput').value = e.target.value;
});
document.getElementById('speedSlider').addEventListener('input', e => {
  document.getElementById('speedInput').value = e.target.value;
});

// Pause / resume
document.getElementById('pauseBtn').addEventListener('click', () => {
  if (!fourier.length) return;
  paused = !paused;
  const btn = document.getElementById('pauseBtn');
  if (paused) {
    btn.textContent = '▶ Resume';
    btn.classList.add('active');
  } else {
    btn.textContent = '⏸ Pause';
    btn.classList.remove('active');
  }
});
document.querySelectorAll('.shape-btn').forEach(b =>
  b.addEventListener('click', () => {
    document.querySelectorAll('.shape-btn').forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    loadPreset(b.dataset.shape);
  })
);

// ── DFT ────────────────────────────────────────────────────────────────────────
// Treat the 2D path as complex numbers: z_n = x_n + i·y_n
// X_k = (1/N) Σ_{n=0}^{N-1}  z_n · e^{−2πi·k·n/N}
//
// Reconstruction at continuous parameter t (0 ≤ t < N):
//   z(t) = Σ_k  X_k · e^{2πi·k·t/N}
//        = Σ_k  amp_k · e^{i·(2π·freq_k·t/N + phase_k)}
//
// So each circle rotates at angular speed  ω_k = 2π·freq_k / N  per unit of t.
// When t advances by N it completes exactly one full cycle.

function dft(pts) {
  const N = pts.length;
  const out = [];
  for (let k = 0; k < N; k++) {
    let re = 0, im = 0;
    for (let n = 0; n < N; n++) {
      const angle = (2 * Math.PI * k * n) / N;
      const c = Math.cos(angle), s = Math.sin(angle);
      // z_n · e^{−iθ} = (x + iy)(c − is) = xc+ys  +  i(yc−xs)
      re += pts[n].x * c + pts[n].y * s;
      im += pts[n].y * c - pts[n].x * s;
    }
    re /= N; im /= N;
    out.push({
      freq:  k,
      amp:   Math.sqrt(re * re + im * im),
      phase: Math.atan2(im, re)
    });
  }
  out.sort((a, b) => b.amp - a.amp);
  return out;
}

// ── Helpers ────────────────────────────────────────────────────────────────────
function resample(pts, N) {
  if (pts.length < 2) return pts;
  // build cumulative arc-length table
  const lens = [0];
  for (let i = 1; i < pts.length; i++) {
    const dx = pts[i].x - pts[i-1].x, dy = pts[i].y - pts[i-1].y;
    lens.push(lens[i-1] + Math.sqrt(dx*dx + dy*dy));
  }
  const total = lens[lens.length - 1];
  const out = [];
  let j = 0;
  for (let i = 0; i < N; i++) {
    const target = (i / N) * total;
    while (j < lens.length - 2 && lens[j+1] < target) j++;
    const span = lens[j+1] - lens[j];
    const frac = span > 0 ? (target - lens[j]) / span : 0;
    out.push({
      x: pts[j].x + frac * (pts[j+1].x - pts[j].x),
      y: pts[j].y + frac * (pts[j+1].y - pts[j].y)
    });
  }
  return out;
}

function centerPts(pts) {
  const cx = pts.reduce((s,p) => s+p.x, 0) / pts.length;
  const cy = pts.reduce((s,p) => s+p.y, 0) / pts.length;
  return pts.map(p => ({ x: p.x - cx, y: p.y - cy }));
}

// ── Animation ──────────────────────────────────────────────────────────────────

function restart() {
  paused = false;
  const btn = document.getElementById('pauseBtn');
  btn.textContent = '⏸ Pause'; btn.classList.remove('active');
  time = 0; tracePoints = [];
  if (animId) { cancelAnimationFrame(animId); animId = null; }
  loop();
}

function loop() {
  animId = requestAnimationFrame(loop);
  render();
  if (!paused) {
    time += animSpeed * 0.5;
    if (time >= dftN) { time -= dftN; }
  }
}

function render() {
  ctx.clearRect(0, 0, W, H);
  drawGrid();
  if (!fourier.length) return;

  const N = Math.min(numCircles, fourier.length);

  // Compute tip position by summing epicycle contributions
  let x = W / 2, y = H / 2;

  for (let i = 0; i < N; i++) {
    const { freq, amp, phase } = fourier[i];
    if (amp < 0.3) continue;

    const px = x, py = y;
    // angle this circle has rotated to at the current time
    const angle = (2 * Math.PI * freq * time) / dftN + phase;
    x += amp * Math.cos(angle);
    y += amp * Math.sin(angle);

    if (showCircles) {
      const alpha = Math.max(0.03, 0.28 - i * 0.0013);
      ctx.beginPath();
      ctx.arc(px, py, amp, 0, 2 * Math.PI);
      ctx.strokeStyle = `rgba(0,229,255,${alpha})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    if (showArms) {
      const alpha = Math.max(0.1, 0.72 - i * 0.009);
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(x, y);
      ctx.strokeStyle = `rgba(0,229,255,${alpha})`;
      ctx.lineWidth = i < 3 ? 1.5 : 0.8;
      ctx.stroke();
    }
  }

  // Glowing tip dot
  ctx.shadowBlur = 14; ctx.shadowColor = '#ffe566';
  ctx.beginPath(); ctx.arc(x, y, 3.5, 0, 2 * Math.PI);
  ctx.fillStyle = '#ffe566'; ctx.fill();
  ctx.shadowBlur = 0;

  // Draw original input shape as a dim ghost for comparison
  if (originalPts.length > 1) {
    ctx.beginPath();
    ctx.moveTo(originalPts[0].x + W/2, originalPts[0].y + H/2);
    for (let i = 1; i < originalPts.length; i++)
      ctx.lineTo(originalPts[i].x + W/2, originalPts[i].y + H/2);
    ctx.closePath();
    ctx.strokeStyle = 'rgba(255,229,102,0.22)';
    ctx.lineWidth = 1.5;
    ctx.lineJoin = 'round';
    ctx.setLineDash([4, 6]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Live trace — sliding window capped to exactly one cycle
  if (!paused) {
    tracePoints.push({ x, y });
    // One cycle = dftN / (animSpeed * 0.5) frames
    const maxPts = Math.ceil(dftN / (animSpeed * 0.5));
    while (tracePoints.length > maxPts) tracePoints.shift();
  }

  if (showTrace && tracePoints.length > 1) {
    ctx.beginPath();
    ctx.moveTo(tracePoints[0].x, tracePoints[0].y);
    for (let i = 1; i < tracePoints.length; i++) ctx.lineTo(tracePoints[i].x, tracePoints[i].y);
    ctx.strokeStyle = 'rgba(255,45,120,0.88)';
    ctx.lineWidth = 1.8;
    ctx.lineJoin = 'round';
    ctx.shadowBlur = 5; ctx.shadowColor = '#ff2d78';
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  document.getElementById('s-n').textContent = N;
  document.getElementById('s-pts').textContent = dftN;
  document.getElementById('s-phase').textContent = (time / dftN * 100).toFixed(1) + '%';
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(28,31,48,0.7)';
  ctx.lineWidth = 1;
  const step = 50;
  for (let gx = 0; gx <= W; gx += step) { ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.stroke(); }
  for (let gy = 0; gy <= H; gy += step) { ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(W,gy); ctx.stroke(); }
}

// ── Draw mode ──────────────────────────────────────────────────────────────────
function enterDrawMode() {
  stopAnim(); sketchPoints = [];
  mode = 'drawing';
  ctx.clearRect(0, 0, W, H); drawGrid();
  setHint('Click and drag to draw your shape, then click ▶ Play');
  document.getElementById('modeTag').textContent = 'DRAW';
  document.getElementById('drawBtn').classList.add('active');
  document.getElementById('playBtn').classList.remove('active');
  document.querySelectorAll('.shape-btn').forEach(x => x.classList.remove('active'));
}

function beginPlay(rawPts) {
  stopAnim();
  document.getElementById('drawBtn').classList.remove('active');
  document.getElementById('playBtn').classList.add('active');
  mode = 'playing';
  document.getElementById('modeTag').textContent = 'PLAYING';
  setHint('');
  const pts = centerPts(rawPts);
  originalPts = pts;
  dftN = pts.length;
  fourier = dft(pts);
  time = 0; tracePoints = [];
  loop();
}

function stopAnim() {
  if (animId) { cancelAnimationFrame(animId); animId = null; }
}

function fullReset() {
  stopAnim();
  sketchPoints = []; originalPts = []; fourier = []; tracePoints = []; time = 0; dftN = 0;
  mode = 'idle';
  ctx.clearRect(0, 0, W, H); drawGrid();
  document.getElementById('modeTag').textContent = 'IDLE';
  document.getElementById('drawBtn').classList.remove('active');
  document.getElementById('playBtn').classList.remove('active');
  document.querySelectorAll('.shape-btn').forEach(x => x.classList.remove('active'));
  ['s-n','s-pts','s-phase'].forEach(id => document.getElementById(id).textContent = '--');
  setHint('Pick a preset or click ✏ Draw to sketch your own shape');
}

function setHint(msg) {
  const el = document.getElementById('hint');
  el.textContent = msg;
  el.style.opacity = msg ? '1' : '0';
}

// ── Mouse / Touch ──────────────────────────────────────────────────────────────
canvas.addEventListener('mousedown', e => {
  if (mode !== 'drawing') return;
  isMouseDown = true; sketchPoints = [];
  const r = canvas.getBoundingClientRect();
  sketchPoints.push({ x: e.clientX - r.left, y: e.clientY - r.top });
});

canvas.addEventListener('mousemove', e => {
  if (!isMouseDown || mode !== 'drawing') return;
  const r = canvas.getBoundingClientRect();
  const p = { x: e.clientX - r.left, y: e.clientY - r.top };
  const last = sketchPoints[sketchPoints.length - 1];
  if (Math.hypot(p.x - last.x, p.y - last.y) > 4) {
    sketchPoints.push(p);
    ctx.clearRect(0, 0, W, H); drawGrid();
    ctx.beginPath();
    ctx.moveTo(sketchPoints[0].x, sketchPoints[0].y);
    sketchPoints.forEach(pt => ctx.lineTo(pt.x, pt.y));
    ctx.strokeStyle = 'rgba(255,229,102,0.85)';
    ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
    ctx.stroke();
  }
});

canvas.addEventListener('mouseup', () => {
  if (!isMouseDown) return; isMouseDown = false;
  if (mode === 'drawing' && sketchPoints.length > 10)
    setHint('Shape captured! Click ▶ Play to animate');
});

canvas.addEventListener('touchstart', e => { e.preventDefault(); const t=e.touches[0]; canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:t.clientX,clientY:t.clientY})); },{passive:false});
canvas.addEventListener('touchmove',  e => { e.preventDefault(); const t=e.touches[0]; canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:t.clientX,clientY:t.clientY})); },{passive:false});
canvas.addEventListener('touchend',   e => { e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mouseup',{})); },{passive:false});

// ── Presets ────────────────────────────────────────────────────────────────────
function loadPreset(name) {
  const N = 512;
  const R = Math.min(W, H) * 0.33;
  const pts = [];

  for (let i = 0; i < N; i++) {
    const t = (2 * Math.PI * i) / N;
    let x = 0, y = 0;

    switch (name) {
      case 'circle':
        x = R * Math.cos(t);
        y = R * Math.sin(t);
        break;

      case 'star': {
        // 5-pointed star: trace outline by interpolating between 10 vertices
        // (alternating outer tips and inner notches)
        const numPoints = 5;
        const outerR = R;
        const innerR = R * 0.4;
        const totalVerts = numPoints * 2; // 10 vertices
        // which segment are we in?
        const progress = i / N * totalVerts; // 0 → 10
        const seg = Math.floor(progress);
        const frac = progress - seg;
        const a0 = (seg / totalVerts) * 2 * Math.PI - Math.PI / 2;
        const a1 = ((seg + 1) / totalVerts) * 2 * Math.PI - Math.PI / 2;
        const r0 = seg % 2 === 0 ? outerR : innerR;
        const r1 = seg % 2 === 0 ? innerR : outerR;
        x = r0 * Math.cos(a0) + frac * (r1 * Math.cos(a1) - r0 * Math.cos(a0));
        y = r0 * Math.sin(a0) + frac * (r1 * Math.sin(a1) - r0 * Math.sin(a0));
        break;
      }

      case 'heart':
        x =  R * 0.75 * 16 * Math.pow(Math.sin(t), 3) / 16;
        y = -R * 0.75 * (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)) / 16;
        break;

      case 'lissajous':
        x = R * Math.sin(3*t + Math.PI/4);
        y = R * Math.sin(2*t);
        break;

      case 'trefoil': {
        const r2 = R * Math.abs(Math.cos(1.5 * t));
        x = r2 * Math.cos(t); y = r2 * Math.sin(t);
        break;
      }

      case 'butterfly': {
        const e = Math.exp(Math.cos(t)) - 2*Math.cos(4*t) - Math.pow(Math.sin(t/12), 5);
        x = R * 0.33 * Math.sin(t) * e;
        y = -R * 0.33 * Math.cos(t) * e;
        break;
      }
    }
    pts.push({ x, y });
  }

  beginPlay(pts);
}

// ── Boot ───────────────────────────────────────────────────────────────────────
drawGrid();
setTimeout(() => {
  document.querySelector('[data-shape="heart"]').classList.add('active');
  loadPreset('heart');
}, 150);
</script>
</body>
</html>
